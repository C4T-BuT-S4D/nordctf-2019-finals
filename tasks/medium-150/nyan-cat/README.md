# Medium-150 | Web/Crypto | Nyan Cat

## Информация

> Кстати, а вы не ветеринар? Мой домашний питомец заболел, и ему срочно нужна квалифицированная помощь. Сможете его вылечить?
> 
> http://address:33044


## Запуск

```sh
docker-compose up --build -d
```


## Описание

На страничке сайта находится гифка со сломанным [Nyan Cat](https://ru.wikipedia.org/wiki/Nyan_Cat) и надпись, сообщающая, что нян-кэт сломан. Если заглянуть в куки, можно заметить [jwt-токен](https://ru.wikipedia.org/wiki/JSON_Web_Token) с сессией вида

```
{
    "broken": true
}
```

При генерации токена использовался алгоритм `RS512`, в заголовках токена можно найти модуль и экспоненту для [RSA](https://ru.wikipedia.org/wiki/RSA).  


## Решение

Попробуем посмотреть на модуль в бинарном виде:

```
bin(n) = 0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010111011001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000110001011
```

В бинарном представлении подозрительно много нулей. При этом, если посмотреть внимательно, похоже, что оба множителя выглядят так:

```
0b1 + 0000...00 + [01]* 
```

Если это правда, то первые k бит модуля как раз являются одним из множителей, умноженным на старший бит другого множителя (то есть самим этим множителем). А `0b11` в середине — это старший бит другого множителя, умноженный на младшие биты первого.

Попробуем взять `p = 0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010111011001`. Тогда при делении модуля на этот множитель мы получаем `q = 0b1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011`, как и ожидалось.

Теперь, когда мы знаем разложение модуля на простые множители, мы можем подделать токен и поставить `{"broken": false}`, чтобы получить флаг.

[Пример эксплоита](exploit.py)


## Флаг

Флаг лежит в файле [service/flag.txt](service/flag.txt).

`flag{thanks_god_you_saved_my_nyan_cat}`
