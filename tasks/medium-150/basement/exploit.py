#!/usr/bin/env python3

from base64 import b64encode, b64decode
from struct import unpack, pack


MBIG = (1 << 31) - 1

INTERNAL_ARRAY_SIZE = 56
FIRST_PART_SIZE = 55
INEXTP_START = 21

ENCODING_TIMES = 16


def predict_next(seedArray, inext, inextp):
    locINext = inext + 1
    locINextp = inextp + 1

    if locINext >= INTERNAL_ARRAY_SIZE:
        locINext = 1
    if locINextp >= INTERNAL_ARRAY_SIZE:
        locINextp = 1

    retVal = seedArray[locINext] - seedArray[locINextp]

    if retVal == MBIG:
        retVal -= 1
    if retVal < 0:
        retVal += MBIG

    seedArray[locINext] = retVal

    return retVal, locINext, locINextp


def main(ciphertext, flag_start):
    for i in range(ENCODING_TIMES):
        flag_start = b64encode(flag_start)

    pt_array = unpack('<' + 'i' * FIRST_PART_SIZE, flag_start[:FIRST_PART_SIZE*4])
    ct_array = unpack('<' + 'i' * (len(ciphertext) // 4), ciphertext)

    internalArray = [0] + list(pt^ct for pt, ct in zip(pt_array, ct_array))

    inext = INTERNAL_ARRAY_SIZE - 1
    inextp = INEXTP_START

    plaintext = flag_start[:FIRST_PART_SIZE*4]

    for i in range(len(ct_array) - FIRST_PART_SIZE):
        retVal, inext, inextp = predict_next(internalArray, inext, inextp)
        plaintext += pack('<i', retVal ^ ct_array[FIRST_PART_SIZE + i])

    for i in range(ENCODING_TIMES):
        plaintext = b64decode(plaintext)

    print(plaintext)


if __name__ == '__main__':
    with open('flag.enc', 'rb') as file:
        ciphertext = file.read()
    main(ciphertext, b'flag{')
